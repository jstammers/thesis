\chapter{MOTMaster}\label{chap:compinterface}

\section{Chapter Overview}\label{sec:compinterface_overview}
The aim of this chapter is to provide a description of the MOTMaster software, which was developed from a pre-existing version during my PhD. The design of MOTMaster assumes very little about the particular experiment it is being used for, so much of the discussion in this chapter will be kept general. This chapter begins by motivating the need to extend MOTMaster by developing a graphical interface to simplify the creation of experimental sequences, as well as implementing new methods of controlling hardware. This is followed by a description of the National Instruments hardware used by MOTMaster to configure the inputs and outputs to an experiment.
\begin{itemize}
    \item New MOTMaster software to control experiment
    \item Control system diagram
    \item Interfacing with muquans/M Squared lasers
    \item Acquiring data from experiment --- axelsuite
\end{itemize}
\section{Motivation}
In the initial stages of my PhD, I decided to use Cicero Word Generator \cite{Keshet2012} to control the hardware for the experiment. This is a graphical-based control system developed by Wolfgang Ketterle's group at MIT, which was designed for controlling atomic physics experiments using National Instruments hardware. Over time, as the experiment became more complex, it started to become apparent that Cicero was not suited to meet all of our requirements for control software. This was most evident in the control of the M-Squared Raman laser system. Unlike the Muquans laser system, which can be controlled externally using analogue and digital voltages and serial messages, the M-Squared system is externally controlled by communicating JSON messages to a web server. Implementing such a drastically different scheme for controlling a specific component into Cicero was not deemed worthwhile. Around this time, I also realised that Cicero takes an appreciable amount of time (around 300ms) to re-calculate the experiment sequence between each shot. Since the design of Cicero was aimed at controlling experiments that take many seconds per cycle, this dead time between each cycle is not significant on those time scales. In contrast, each cycle of this experiment takes around 250ms. This unnecessary dead time needed to be addressed if we hoped to improve the repetition rate. \\
After it became clear that a potentially large amount of work would be needed to improve Cicero, I decided that it was worth moving to a new control system. Within \ac{ccm}, there is a collection of programs that are used to control a range of experiments. One of these, MOTMaster, was designed to control and acquire data from experiments investigating cold atoms trapped in a \ac{mot}, as its name suggests.\\
{\Huge Write more to motivate the switch to MOTMaster}

\section{Interfacing wth Hardware}
The majority of the experimental hardware is controlled using analogue and digital voltages that are generated by \ac{daq} cards manufactured by National Instruments. MOTMaster is compatible with cards that use either the NI-DAQmx or NI-HSDIO device drivers. These are used to configure the generation or acquisition of digital or analogue voltage waveforms and are capable of precisely timing and synchronising their I/O across multiple devices. Most components in the experiment rely on this precise timing to function correctly. Other devices, where timing accuracy is less critical, are controlled by sending or receiving data using serial communication. This has the advantage of allowing more structured command beyond analogue or digital voltages, but the communication speed of the serial channel limits the accuracy of the execution time. An understanding of the low-level interface between control software and the experiment is very useful in both carrying out experiments and accurately interpreting the results.
\subsection{Hardware Abstraction}\label{subsec:compinterface_hwabstraction}
When designing software, it is often useful to structure a program in such a way that modules which make use of other components do not need to know about their specific implementation in order to use them. In doing this, the submodule can be modified without harming the compatibility of these two components. In the context of experimental hardware, this is equivalent to requiring that changing specific components, for example the \ac{vco} that generates the RF power for an \ac{aom}, will not stop the experiment from working. This is done using abstract representations of the hardware, in the form of input and output channels that are used to communicate to each device. 
\subsection{Voltage Pattern Generation}\label{subsec:compinterface_patterngen}
All the analogue outputs controlled using MOTMaster are done using the NI-DAQmx software. Each output uses a \ac{dac} to convert a floating-point number into an analogue voltage. To generate a sequence of voltages across multiple channels, the NI-DAQmx driver allocates a block of memory on the \ac{daq} card for each output channel. This memory acts as a first-in first-out (FIFO) buffer for data streamed to it from a computer. The output of each channel is synchronised to a clock signal, so that every time a rising edge occurs on the clock, the voltage at each output transitions to the value corresponding to the next value in its corresponding buffer. Channels across multiple \ac{daq} cards can be synchronised by sharing a clock signal, which can be done using the bus that connects cards in a PXIe chassis. Additional cards can also be configured to trigger the start of their output at the moment they receive the first clock pulse, rather than waiting for a command from the computer to start. \par\noindent 
Digital outputs from NI-DAQmx cards are generated in much the same way as analogue voltages, except for the fact that they only take two values corresponding to either a low (0 V) or high (3.3/5 V) level. \ac{daq} cards which operate using the NI-HSDIO driver function differently. These cards have faster on-board clocks than is usually available with NI-DAQmx hardware. For instance, NI-DAQmx PXI-6723 can operate with a maximum clock frequency of 200 kHz and typical sequence durations mean that a sample rate of 100 kHz is needed to fit the entire sequence into memory. However, the NI-HSDIO PXI-6541 card can generate digital voltages at sample rates up to 50 MHz and requires less memory to store a pattern. Rather than write the pattern as an array of values for each sample, the sequence is segmented into smaller patterns during which the state of each channel is constant, as illustrated in \FigureRef{fig:hsdio_timing}. NI-HSDIO cards can be scripted to generate each of these patterns for the appropriate number of clock cycles.
\begin{figure}
    \centering
    %\includegraphics[width=0.5\textwidth]{}
    \caption[Scripted pattern generation for an NI-HSDIO card]{Scripted pattern generation for an NI-HSDIO digital output card. A pattern is split into segments which correspond to a duration for which all the channels output a constant value. Each of these smaller waveforms are written to the on-board memory, along with a script that instructs the card to output each pattern for the required number of times to reconstruct the original sequence. By reducing the amount of memory required to define the sequence, a faster clock frequency and hence timing resolution can be used to output digital control signals.}
    \label{fig:hsdio_timing}
\end{figure}
\subsection{Timed Serial Communication}\label{subsec:compinterface_serial}
Serial communication is used to control devices which require more complex control than is possible using analogue or digital voltages. This increase in complexity comes at the cost of slower response times, because it takes longer to communicate an array of bytes is longer than to change the voltage across an output terminal. Using the NI-VISA driver, the output of serial data can only be timed using a software clock on a computer, which is more prone to jitter than a hardware clock. One way to improve the synchronisation between serial data and hardware timed outputs is to use extra hardware to trigger the transmission of serial data. If the trigger is timed using the same clock as other outputs and the transmission delay is accounted for, then serial data can be output more synchronously. The scheme for timing serial messages is shown in \FigureRef{fig:serial_timing}. Serial messages are stored as strings on the computer and a counter channel is configured so that every time it detects a rising edge, the computer outputs the next message. This counter is connected to a digital output channel, so that it acts as a trigger for the serial data output. Using this method, multiple serial messages can be sent to one device during a sequence even for devices which have no means of storing commands.
\begin{figure}
    \centering
    %\includegraphics[width=0.5\textwidth]{filename}
    \caption[Timing diagram for serial communication]{Timing diagram for serial communication. A counter channel is configured to count edges from a digital output channel. Every time it sees a rising edge, it triggers the output of the next message on each serial channel from the computer. Multiple messages can be communicated during a single sequence without the need for software timing.}
    \label{fig:serial_timing}
\end{figure} 
\subsection{Voltage Acquisition}\label{subsec:compinterface_mmacquisition}
Analogue input channels are configured in a similar way to analogue output channels. A block of memory is allocated on the \ac{daq} card for each input channel. Once the card is triggered to start acquiring, an \ac{adc} converts the voltage across the input into a digital value at every rising edge of the clock signal. Once the sequence has finished, or the buffer has been filled, the card streams this data to the computer. 

\section{External Control}

\section{Building a Sequence}

\section{Experimental Sequence Structure}
